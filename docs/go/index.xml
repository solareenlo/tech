<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on solareenlo</title><link>https://solareenlo.com/tech/docs/go/</link><description>Recent content in Go on solareenlo</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://solareenlo.com/tech/docs/go/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://solareenlo.com/tech/docs/go/closure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://solareenlo.com/tech/docs/go/closure/</guid><description> closure とは # 関数オブジェクトの1つ． 引数以外の変数を実行時の環境ではなく，closure が定義されている環境（静的スコープ）において解決することを特徴とする． closure のメリット # closure を高階関数の引数に渡して，記述の簡素化や高階関数の外側の状態の参照が可能になる． closure は遅延評価される（呼び出されるまで何も実行しない）ので，制御構造の定義に用いることができる． Go の関数は closure # closure は closure 自身の外部から変数を参照する関数値のことであり， closure は参照された変数へアクセスして変えることができる． その意味で，closure はその変数へ bind されている． Go における closure としての無名関数の特徴 # closure から参照されたローカル変数は，関数内のローカル変数とは別物になりclosure の変数になる． closure が何らかの形で参照される限り closure の変数も破棄されない．</description></item><item><title/><link>https://solareenlo.com/tech/docs/go/declaration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://solareenlo.com/tech/docs/go/declaration/</guid><description> Declaration Syntax # 公式による解説ブログ # Go&amp;rsquo;s Declaration Syntax 上記の日本語訳: Go&amp;rsquo;s Declaration Syntaxのゆるーい和訳</description></item><item><title/><link>https://solareenlo.com/tech/docs/go/interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://solareenlo.com/tech/docs/go/interface/</guid><description>interface # method の一覧を定義する型． 型に method を実装することによって，interface を実装する． interface を明示的に宣言する必要はない． この定義と実装を切り離していることを暗黙のインターフェースという． interface をこのような実装にした理由の1つは，同じインターフェースを実装する異なる構造体を，新たな型として定義できるから． interface value # インターフェースの値は，下のような値と具体的な型のタプルのように考えることができる． (value, type) インターフェースの値は，特定の基底になる具体的な型の値を保持する． インターフェースの値のメソッドを呼び出すと，その基底型の同じ名前のメソッドが実行される． インターフェース自体の中にある具体的な値が nil の場合，メソッドは nil をレシーバーとして呼び出される． 具体的な値として nil を保持するインターフェースの値それ自体は非 nil である． nil interface # nil interface の値は，値も具体的な型も保持しない． nil interface には呼び出す具体的なメソッドを示す型がタプル内に存在しないため，nil interface のメソッドを呼び出すと，ランタイムエラーになる． empty interface # empty interface は0個のメソッドを指定されたインターフェースのこと． empty interface は，任意のかたの値を保持できる． 全ての型は，少なくとも0個のメソッドを実装している． type assertion # type assersion は，interface の値の基になる具体的な値を利用する手段を提供する． t := i.(T) 上の文は，interface の値 i が具体的な型 T を保持し，基になる型 T の値を変数 t に代入することを主張する． i が T を保持していない場合，上の文は panic を引き起こす． interface の値が特定の型を保持しているかどうかをテストするために，type assersion は2つの値を返すことができる． 2つの値とは，基になる値とアサーションが成功したかどうかを報告するブール値． t, ok := i.</description></item><item><title/><link>https://solareenlo.com/tech/docs/go/slice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://solareenlo.com/tech/docs/go/slice/</guid><description> slice # 可変長配列を持たない代わりに実装された型． 配列全体のポインタ（ptr），配列の長さ（len），配列の容量（cap）を保持するデータ構造． 配列の部分列を簡単に取り出せる． 公式による解説ブログ # Go Slices: usage and internals slice と array の定義 # slice の定義 # test := []int{1, 2, 3} //要素数3 容量3の slice test := make([]int, 3, 3) //要素数3 要素数3の slice array の定義 # var test[] //要素数0 容量0の array var test[10] //要素数10 容量10の array test := [3]int{1, 2, 3} //要素数3 容量3の array test := [...]int{1, 2, 3} //要素数3 容量3の array Reference: Go言語のスライスで勘違いしやすいこところ</description></item><item><title/><link>https://solareenlo.com/tech/docs/go/vim-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://solareenlo.com/tech/docs/go/vim-go/</guid><description> vim-go # vim 用の Go 開発プラグイン GitHub: fatih/vim-go 日本語訳 # GitHub: hnakamur/vim-go-tutorial-ja</description></item><item><title>method &amp; receiver</title><link>https://solareenlo.com/tech/docs/go/method-receiver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://solareenlo.com/tech/docs/go/method-receiver/</guid><description> method # Go には class が無い． その代わりに，receiver を用いて type に method を定義する． receiver # receiver は，func キーワードと method の間に引数リストをとる． receiver には，変数レシーバーとポインターレシーバーがある． 変数レシーバーは元の変数のコピーを操作する． ポインターレシーバーは元の変数を変更する． pointer reciever # メソッドがポインターレシーバーの場合，呼び出し時に，変数またはポインタのいずれかをレシーバーとして取ることができる． ポインターレシーバーが引数に変数を受け取るとポインターとして解釈してくれる． 利便性のために． ポインタレシーバーを使う理由は メソッドがレシーバーが指す先の変数を変更するため． メソッドの呼び出し毎に変数のコピーを避けるため．</description></item></channel></rss>